# [世代管理機能] 改修設計仕様書

## 1. 改修の目的・背景

* **背景**: [複数の入出力を持つ計算グラフや、可変長引数への対応が必要となったため。また、複雑な接続を持つグラフにおいて、正しい順序で逆伝播（backward）を行うための世代管理が必要となった。]
* **目的**: [可変長引数への対応勾配の加算（累積）ロジックの実装およびheapqを用いた世代（generation）による逆伝播の優先順位付けを導入する]

## 2. 変更内容一覧

| クラス名 | 関数/メソッド名 | 変更の概要 |
| --- | --- | --- |
| `Function` | `__call__` | 可変長引数（*inputs）への対応、および入力値の最大世代を自身の世代として設定するロジックの追加。 |
| `Variable` | `backward` | `heapq` を用いた世代順の関数取り出し、可変長引数への対応、および勾配（grad）の加算ロジックの実装。 |
| `Variable` | `cleargrad` | 勾配を `None` にリセットする機能の追加。 |
| `Variable` | `add_func` | `heapq` を利用し、世代数に基づいた優先度付きキューに関数を追加する機能（重複防止含む）。 |
| `Add` | `forward` | 引数で直接 `x0, x1` を受け取る仕様に変更。 |
| `Square` | `backward` | メンバ変数から入力値を取り出す際、インデックス[0]を指定するよう変更。 |

## 3. 詳細設計（Before & After）

### 3.1 [Function.**call**]

#### 変更前 (Before)

* 単一の入力を受け取る想定であり、世代（generation）の概念がなかった。

#### 変更後 (After)

* **引数構成**: 可変長引数 `(*inputs)` に変更。
* **世代管理**: `self.generation = max([x.generation for x in inputs])` により、入力の最大世代を記録。
* **データ処理**: リスト内表記を用いて入力データを `Variable` 化し、出力がタプルでない場合はタプルへ変換して返す（インデックス[0]を返す）。

### 3.2 [Variable.backward]

#### 変更前 (Before)

* 単純なリストに親関数を格納し `pop()` で取り出していたため、複雑なグラフで計算順序が前後する可能性があった。
* 勾配の代入に `+=` を想定しておらず、同じ変数を複数回使用した際に値が上書きされていた。

#### 変更後 (After)

* **抽出ロジック**: `heapq` を使用した優先度付きキュー（`funcs` リスト）に変更。
* **格納形式**: `(-f.generation, id(f), f)` の形式で保存し、常に世代が最大の関数から抽出する。
* **勾配累積**: `x.grad` が `None` の場合は直接代入し、値がある場合は加算を行う（`+=` 演算子による上書き副作用を避ける）。

## 4. 影響範囲と整合性

* **関連1**: `Function` クラスの各サブクラス（`Add` や `Square`）は、入出力がリスト/タプル形式であることを前提とした実装に変更する必要がある。
* **関連2**: 逆伝播を開始する際、`Variable` の世代が正しく設定されている必要がある（`Variable` 生成時は0、`set_creator` 時に `f.generation + 1`）。

## 5. テスト・検証項目

* [X] 複雑な分岐を持つグラフ（`add(x, x)` など）で、勾配が上書きされず正しく合算されるか。
* [X] `heapq` により、世代が深い（大きい）関数から順番に `backward` が実行されているか。
* [X] 同じ関数が二度キューに入らない（`id()` による重複チェックが機能しているか）。
* [X] `cleargrad` を実行した際、保持していた勾配が正しく `None` にリセットされるか。

