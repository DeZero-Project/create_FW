# [Utilモジュール関数追加] 改修設計仕様書

## 1. 改修の目的・背景
- **背景**: 既存のUtilsモジュールには計算グラフの可視化ロジックしか定義されておらず、DeZeroの計算基盤となる数学補助関数や、信頼性を担保する勾配検証機能の仕様が未整備であった
- **目的**: ブロードキャストやファイル取得など、開発に必要な補助機能の追加

## 2. 変更内容一覧

| カテゴリ | 関数/メソッド名 | 変更の概要 |
| --- | --- | --- |
| **演算** | `sum_to` | ブロードキャストされた配列を特定の形状に合計する |
|  | `reshape_sum_backward` | `sum`の逆伝播用に勾配の形状を調整する |
|  | `logsumexp` | 数値的に安定した対数和指数計算を行う |
|  | `max_backward_shape` | `max`の逆伝播用形状を算出する |
| **検証** | `gradient_check` | 数値微分とバックプロパゲーションの結果を比較する |
|  | `numerical_grad` | 中心差分による数値微分を計算する |
|  | `array_equal` | 配列の完全一致を確認する |
|  | `array_allclose` | 許容誤差内での配列の一致を確認する |
| **補助** | `show_progress` | コンソールにダウンロード進捗を表示する |
|  | `get_file` | キャッシュ機能付きのファイル取得を行う |
|  | `get_conv_outsize` | 畳み込みの出力サイズを計算する |
|  | `get_deconv_outsize` | 逆畳み込みの出力サイズを計算する |
|  | `pair` | 入力値を2要素のタプルに正規化する |

---

## 3. 詳細設計（関数別）

### 3.1 `sum_to(x, shape)`

* **データ構造**: 入力 `x` と目標 `shape` の次元差に基づき、和を取る軸を決定する。
* **処理フロー**:
1. 入力 `x` の次元数と目標 `shape` の次元数の差 `lead` を算出する。
2. `shape` 内で要素数が1の軸と、`lead` 分の軸を統合し `axis` を特定する。
3. `keepdims=True` を指定して、指定軸で和を計算する。
4. `lead` が正の場合、`squeeze` で余分な次元を除去して返す。



### 3.2 `reshape_sum_backward(gy, x_shape, axis, keepdims)`

* **データ構造**: `sum` 関数の逆伝播において、スカラーや圧縮された勾配を元の入力形状にブロードキャスト可能にする。
* **処理フロー**:
1. 入力形状 `x_shape` から次元数 `ndim` を取得し、`axis` をタプルに正規化する。
2. `ndim` が 0 でなく、かつ `keepdims` が False の場合の形状補正を行う。
3. 補正が必要な場合、指定された `axis` の位置にサイズ 1 の次元を挿入した `shape` リストを作成する。
4. `gy.reshape(shape)` を実行して返す。



### 3.3 `logsumexp(x, axis=1)`

* **データ構造**: NumPy/CuPy 配列を受け取り、オーバーフローを防ぎながら計算を行う。
* **処理フロー**:
1. 配列モジュール `xp` を取得し、指定軸の最大値 `m` を計算する。
2.  の指数 `exp` を計算する（数値安定化）。
3. 指数和の対数 `log` を取り、最後に最大値 `m` を加算して結果を返す。



### 3.4 `max_backward_shape(x, axis)`

* **処理フロー**:
1. `axis` が None なら全次元、整数ならタプルへ変換する。
2. `x.shape` の各次元について、`axis` に含まれるものは 1、それ以外は元のサイズを維持したシェイプを作成する。
3. 作成したリストを返す。



### 3.5 `gradient_check(f, x, *args, **kwargs)`

* **処理フロー**:
1. `as_variable(x)` で入力を `Variable` 化し、`numerical_grad` で数値微分を算出する。
2. `f(x)` を実行後 `y.backward()` を呼び出し、バックプロパゲーションの勾配を取得する。
3. 両者の形状一致を `assert` で確認する。
4. `array_allclose` で値の誤差を検証し、失敗時は詳細をコンソール出力する。



### 3.6 `numerical_grad(f, x, *args, **kwargs)`

* **処理フロー**:
1. `eps = 1e-4` を設定し、`x` と同じ形状の `grad` 配列を初期化する。
2. `np.nditer` で `x` の全要素を巡回し、対象要素の値を一時保存する。
3. 対象要素を `+eps` して `f(x)` を計算（`y1`）、`-eps` して `f(x)` を計算（`y2`）する。
4. `(y1 - y2).sum() / (2 * eps)` を計算し、`grad` に格納後、値を元に戻す。
5. 全要素巡回後、`grad` を返す。



### 3.7 `array_equal(a, b)`

* **処理フロー**:
1. `a`, `b` が `Variable` ならそのデータ部分を取り出す。
2. 両者を NumPy 配列に変換する。
3. `np.array_equal` の結果を返す。



### 3.8 `array_allclose(a, b, rtol=1e-4, atol=1e-5)`

* **処理フロー**:
1. `a`, `b` が `Variable` ならデータを取り出し、NumPy 配列に統一する。
2. `np.allclose` を用いて、指定された許容誤差内での一致判定を返す。



### 3.9 `show_progress(block_num, block_size, total_size)`

* **処理フロー**:
1. 現在のダウンロード済みサイズと進捗率 `p` を計算する。
2. 進捗率に応じた `#` の数（最大30個）を算出し、バー文字列を作成する。
3. `\r` を用いて同一行にプログレスバーとパーセンテージを表示する。



### 3.10 `get_file(url, file_name=None)`

* **処理フロー**:
1. キャッシュディレクトリの存在を確認し、なければ作成する。
2. 保存先パス `file_path` を決定し、ファイルが既に存在すればそのパスを即座に返す。
3. 存在しない場合、`urllib.request.urlretrieve` を用いてダウンロードを実行する。
4. 中断やエラーが発生した場合は、中途半端なファイルを削除して例外を投げる。



### 3.11 `get_conv_outsize(input_size, kernel_size, stride, pad)`

* **処理フロー**:
1. 入力値に対し、 を計算して返す。



### 3.12 `get_deconv_outsize(size, k, s, p)`

* **処理フロー**:
1. 入力値に対し、 を計算して返す。



### 3.13 `pair(x)`

* **処理フロー**:
1. `x` が `int` なら `(x, x)` のタプルを返す。
2. `x` が `tuple` なら長さが 2 であることを確認してそのまま返す。
3. それ以外の場合は `ValueError` を送出する。



---

## 4. 追加変数一覧

| 追加先関数名 | 変数名 | 役割 |
| --- | --- | --- |
| `sum_to` | `lead_axis` | 次元を合わせるために追加・削除する軸のタプル |
| `numerical_grad` | `it` | `np.nditer` による全要素巡回用イテレータ |
| `get_file` | `cache_dir` | ファイルを保存するローカルディレクトリパス |

## 5. 影響範囲と整合性

* `utils.py` の全関数が、フレームワークの基本的な算術演算、CNNレイヤの形状計算、および開発時の自動テスト（勾配確認）の基盤となります。

## 6. テスト・検証項目

* [ ] 各演算補助関数が、NumPyの標準的な挙動と一致する出力を出すか。
* [ ] `get_file` が、オフライン環境や書き込み権限のないディレクトリで適切にエラーを処理するか。
* [ ] `pair` が `(1, 2, 3)` などの不正な長さのタプルに対して例外を投げるか。
