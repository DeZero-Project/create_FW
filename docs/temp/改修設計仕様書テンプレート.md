# [改修名] 改修設計仕様書

## 1. 改修の目的・背景
- **背景**: [例：計算グラフが複雑になり、逆伝播の実行順序が不安定になった]
- **目的**: [例：世代管理を導入し、優先度付きキューを用いて実行順序を厳密に制御する]

## 2. 変更内容一覧
影響範囲をクラス単位で整理します。

| クラス名 | 関数/メソッド名 | 変更の概要 |
| :--- | :--- | :--- |
| `Variable` | `backward` | 優先度付きキュー（heapq）の導入、世代順処理への変更 |
| `Function` | `__call__` | 世代の計算ロジックの追加 |

## 3. 詳細設計（Before & After）
ロジックがどう変わったかを対比させます。

### 3.1 [対象関数名]
#### 変更前 (Before)
- [例：単なるリストにappendし、pop()で取り出していた]

#### 変更後 (After)
- **データ構造**: `heapq` を使用した優先度付きキューに変更。
- **格納形式**: `(-generation, id, function)` のタプル形式で保存。
- **抽出ロジック**: `heappop` を使用し、常に最大世代の要素を抽出する。

### 3.2 追加変数一覧
追加する変数名とその役割を整理

| 追加先クラス名 | 追加先関数/メソッド名 | 変数名 | 役割 | 挿入箇所 |
| :--- | :--- | :--- | :--- |:--- |
| `Variable` | `backward` | `funcs` | ` heapq.heappush()`で取り出した値を格納するリスト | `def add_func(f):`の直前 |

### 3.3 変更後処理フロー
ロジック変更後の処理概要とフローを記載
[例：if文を使いfunc.outputの値がNullだった場合の処理を追加]
1. リスト`funcd = []`を追加
2. 条件式`if(func.output is not None)` を追加
    - 2.2 もしNoneだった場合エラーメッセージを返す
3. ...

## 4. 影響範囲と整合性
この改修によって修正が必要になる関連箇所。
- **関連1**: `Function`クラスの `self.generation` が正しく計算されている必要がある。
- **関連2**: `backward`開始時に `self.grad` の初期化（1.0代入）が必須となる。

## 5. テスト・検証項目
改修が正しく行われたかをどう確認するか。
- [ ] 複雑な分岐を持つグラフ（add(x, x)など）で勾配が正しく合算されるか。
- [ ] 同じ関数が二度キューに入らない（seen_setの機能確認）。